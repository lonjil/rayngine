(in-package #:rayngine)

(declaim (ftype (function (v3:vec sphere v3:vec) (single-float)) sphere-distance))
(defun sphere-distance (point sphere cache)
  (declare (optimize speed)
           (v3:vec point cache) (sphere sphere))
  (- (v3:length (v3:-! cache (sphere-center sphere) point))
     (sphere-radius sphere)))

(declaim (ftype (function (v3:vec plane v3:vec) (single-float)) plane-distance))
(defun plane-distance (point plane cache)
  (declare (optimize speed)
           (v3:vec point) (plane plane))
  (v3:dot (plane-normal plane) (v3:-! cache point (plane-point plane))))

(defun scene-distance (point scene cache)
  (declare (optimize speed))
  (let ((min 1000f0))
    (dolist (x scene)
      (let* ((shape (thing-shape x))
             (dist (typecase shape
                     (sphere (sphere-distance point shape cache))
                     (plane (plane-distance point shape cache)))))
        (when (< dist min) (setf min dist))))
    min))

(defun softshadow (point dir light light-distance state)
  (declare (optimize speed) (light light))
  (let ((s 1f0)
        (w (light-width light))
        (max-dist light-distance)
        (dist 5f-3)
        (cache (state-temp state))
        (p (state-cache state)))
    (declare (single-float s dist max-dist) (v3:vec p))
    (v3:+! p point (v3:scale! p dir dist))
    (loop :for h single-float := (scene-distance p (state-scene state) cache)
          :until (or (>= dist max-dist) (<= h 1f-5))
          :do (setf s (min s (+ 0.5f0 (/ (* h 0.5f0) (* w dist)))))
              (when (< s 4f-4) (return))
              (incf dist h)
              (v3:+! p point (v3:scale! p dir dist)))
    (setf s (max s 0f0))
    (* s (* s (- 3f0 (* 2f0 s))))))
